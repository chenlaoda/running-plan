<script>
    // 1.【关于函数参数】下面代码的执行结果是什么
    // function getInfo(member, year) {
    //     member.name = "Alice";
    //     year = "2020"
    // }
    // var person = { name: "Tom" }
    // var brithYear = "2010";
    // getInfo(person, brithYear);
    // console.log(person, brithYear);
    // //答案：{name:Alice},2010


    // 2.【Event Loop】下面代码的执行结果是什么
    // var p = new Promise(resolve => {
    //     console.log(4);
    //     resolve(5);
    // });
    // function func1() {
    //     console.log(1)
    // }
    // function func2() {
    //     setTimeout(() => {
    //         console.log(2)
    //     });
    //     func1();
    //     console.log(3);
    //     p.then(resolved => {
    //         console.log(resolved)
    //     }).then(() => {
    //         console.log(6)
    //     });
    // }
    // func2();
    // 答案：4 1 3 5 6 2
    // 解析：事件循环机制，主程序执行完，再执行微队列，再执行宏队列；Promise then会先进入微队列，setTimeout进入宏队列。


    // 3. 下面的代码的执行结果是什么
    // function Car(){
    //     this.name = "BMW"
    //     return {
    //         name:"maserati"
    //     }
    // }
    // var car = new Car();
    // console.log(car.name);
    // 答案：maserati
    // 解析：new构造函数产生对象时，有显示返回一个对象的情况，this就是该对象。


    // 4. 模拟实现placeholder作用
    // <input type="text" name="user" value="请输入用户名" style="color:#999"
    //  onfocus="if(this.value=='请输入用户名'){this.value = '';this.style.color='#424242'}"
    //  onblur="if(this.value == ''){this.value = '请输入用户名';this.style.color='#999'}" >


    // 5. 下面代码的执行结果是什么
    // var a = 1;
    // var b = 2[a,b] = [b,a]
    // console.log(a,b)
    // 答案：a是1，b是[undefined , 1]   
    // 解析：预编译和包装类对象的结果


    // 6. 下面代码最后打印arr是什么
    // var arr = [1,2,3,4,5];
    // arr.length = 1;
    // 答案：[1]
    //解析：length会影响数组


    // 7.  下面代码执行结果是什么
    // var arr = [1+1,1*2,1/2];
    // console.log(arr);
    // 答案：[2,2,0.5]
    // 解析：数组保存的时候，每一位的表达式都会先运算


    // 8. 下面代码的执行结果是?
    // var one = (false || {} || null);
    // var two = (null || false || "");
    // var three = ([] || 0 || true);
    // console.log(one,two,three);
    // 答案：{},"",[]
    // 解析：本题考查||运算符的用法。其实记住一条规律：||运算符返回的是能确认最终结果的值！


    // 9. 下面代码执行结果是？
    // var h5course = false;
    // var result = h5course / 0;
    // if (result) {
    //     console.log(result * 2 + '2' + 4)
    // } else {
    //     console.log(!result * 2 + '2' + '4')
    // }
    // 答案："224"
    // 解析：0/0,null/0,undefined/0,false/0都为NaN，其他正数/0为infinity，其他负数除以0位-infinity。!NAN为true，true*2为2


    // 10. 下面代码执行结果是什么？
    // var a = 0, b=0;
    // function A(a){
    //     A = function(b){
    //         alert(a + b++)
    //     }
    //     alert(a++)
    // }
    // A(1)
    // A(2)
    // 答案：1，4
    // 解析：深入预编译和闭包就会得出结果，如下：
    // 首先：A(1)执行前 全局GO{
    //                         a：0,
    //                         b：0,
    //                         A：function A(a){}
    //                     }
    // 当A(1)执行的时候会产生一个放在自己作用域最顶端的的AO：{
    //                                                     a:1
    //                                                   }
    //                                               GO变成：{
    //                                                   a:0,
    //                                                   b:0,
    //                                                   A:function(b){alert(a + b++)}
    //                                                     //注意这里相当于window.A = function(b){alert(a + b++)},
    //                                                     //就跟函数保存到外部一样，产生了闭包。会拿着A(1)执行的AO{a:2}
    //                                               }   
    // 所以这里console.log(a++)，对应的是自己的AO里的a，后++，即打印出：1 ， 然后AO里面的a变成2，执行完销毁AO，
    // 注意：当A(2)执行的时候是执行GO里的A:function(b){alert(a + b++)}
    // 所以A(2)执行时，其[[scope]][0]是全新的AO{                        
    //                                          b：2                                  
    //                                      }
    //                          [[scope]][1]：{
    //                                          a：2
    //                                       }  
    //                          [[scope]][2]是GO{
    //                                           a:0,
    //                                           b:0,
    //                                           A:function(b){alert(a + b++)}
    //                                       }          
    // 所以alert(a + b++)，即2 + 2 ,这里打印出4
    // 所以最后结果分别打出1，4

    // 11. 下面代码的执行结果是？
    // var str = new Array(5).toString()
    // console.log(str);
    // 答案：",,,,"
    // 解析：new Array(n) 返回的是以length为n、每一位为空的数组。
    // 所以正因为new Array有这样那样的问题，一般推荐使用字面量如：var arr = [5]


    // 12. 下面代码的执行结果是什么？
    // console.log(123..toString());
    // 答案："123"
    // 解析：包装类的原因，js会将123.通过new Number(123.)打包成包装类对象。调用的是Number.prototype.toString
    // 所以new Number(123.).toString === Number.prototype.toString   


    // 13. 下面代码的执行结果是？
    // var x = 1;
    // var y = 2;
    // function show() {
    //     var x = 3;
    //     return {
    //         x: x,
    //         fun: function (a, b) {
    //             x = a + b;
    //         }
    //     }
    // }
    // var obj = show();
    // obj.fun(x, y);
    // console.log(obj.x)
    // console.log(x)
    // 答案：3，1
    // 解析：考查知识点闭包和预编译
    // 首先：
    // GO:{
    //     x:1,
    //     y:2,
    //     show:function(){},
    //     obj:undefined
    // }
    // 接着执行到obj = show(),show执行产生一个自己的AO
    // AO:{
    //     x:3
    // }
    //同时返回一个对象，形成闭包，obj={
    //                             x: 3,
    //                             fun: function(a, b) {
    //                                     x = a + b;
    //                                 }
    //                             }
    // 接着执行obj.fun(x,y),即：obj.fun(1,2)
    // 到这里一起来屡屡fun的[[scope]]
    // [[scope]][0]---->{
    //     a:1,
    //     b:2
    // }
    // [[scope]][1]---->{
    //     x:3
    // }
    // [[scope]][2]---->{
    //     x:1,
    //     y:2,
    //     show:function(){},
    //     obj:{x:3,fun:function(){}},
    // }
    // 所以执行obj.fun(1,2)时，里头就是x = 3，而GO上的x没有改变
    // 这时候console.log(obj.x)，打印3；console.log(x)也为1

    // 14. 下面的代码执行结果是？
    // var a = (true + false) > 2 + true;
    // console.log(a);
    // 答案：false
    // 解析：涉及知识点运算符的计算顺序和类型转换；
    // 有()先算()，存在隐式类型转换true + false 变成1+0，
    // 算数运算优先比较运算符，所以先算2+1
    // 最后比较是：1>3 得出false


    // 15. 说说运算符的优先级
    // 【小括号()】 > 【逻辑非!】 > 【算数*/%】> 【算数+-】> 【关系比较><==】 > 【逻辑与&&、逻辑或||】 > 【三目 ? :】 > 【赋值=】
    // 大致是这样，具体可以查看这篇文档，里面有个表：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence


    // 16. 下面代码执行结果是？
    // var num = 3;
    // console.log(num.toString(2));
    // console.log(num.toFixed(2));
    // 答案：11、3.00
    // 解析：toString方法传入一个参数时，表示把一个数当成10进制转成对应的进制的数，这里3被当成10进制，变成2进制就是11；
    // toFixed方法把目标数变成保留指定位数的小数，注意会四舍五入！这里保留两位小数，即变成3.00

    // 17. 下面代码的执行结果是什么？
    // function a(x){
    //     return x*2
    // }
    // var a;
    // console.log(a);
    // 答案：function a(x){return x*2}

    // 18. 下面代码的运行结果是什么？
    // function fun(n, o) {
    //     console.log(o);
    //     return {
    //         fun: function (m) {
    //             return fun(m, n);
    //         }
    //     }
    // }
    // var a = fun(0);
    // a.fun(1);
    // a.fun(2);
    // a.fun(3);
    // var b = fun(0).fun(1).fun(2).fun(3);
    // var c = fun(0).fun(2);
    // c.fun(2);
    // c.fun(3);
    // 答案：
    // undefined 0 0 0 
    // undefined 0 1 2 
    // undefined 0 2 2

    // 19. 下面代码的执行结果是？
    // var a = []+[]+"alice".split("");
    // console.log(a);
    // 答案："a,l,i,c,e"
    // 解析：[]+[]为空字符串'',空字符串加数组，等于把数组变成字符串的形式，相当于数组调用了toString

    // 20.有两个变量a和b，其值为number类型且非NaN，不借助其他变量，完成a与b的交换
    // 答案：方式有很多种，下面是其中给一种
    // var a = 101;
    // var b = 102;
    // a = a + b;
    // b = a - b;
    // a = a - b;
    // console.log(a,b)

    // 21. 下面代码的执行结果是？
    // function Point(x, y) {
    //     this.x = x;
    //     this.y = y;
    //     this.moveTo = function (x, y) {
    //         this.x = x;
    //         this.y = y;
    //         console.log(this.x, this.y)
    //     }
    // }
    // var p1 = new Point(0, 0);
    // var p2 = { x: 0, y: 0 };
    // p1.moveTo(1, 1);
    // p1.moveTo.apply(p2, [10, 10])
    // 答案：1,1 和 10,10
    // 解析：this指向有两点，(1) 函数谁调用里面this指向谁，(2) apply call bind可改变函数执行时的this指向

    // 22. 下面代码的执行结果是什么？
    // var globalVar = 0;
    // (function (outerArg) {
    //     var outerVar = 456;
    //     (function (innerArg) {
    //         var innerVar = 10;
    //         console.log(globalVar, outerArg, outerVar, innerArg, innerVar);
    //     }(789))

    // }(123))
    // 答案：0，123，456，789，10
    // 解析：立即执行函数与普通函数执行没有区别

    // 23. 下面代码执行结果是什么？
    // console.log(1 + undefined);//NaN
    // console.log(1 + null);//1
    // console.log(null + undefined);//NaN 
    // console.log(true + false);//1
    // console.log(1 + '2');//12
    // console.log(2 + []);//2
    // console.log(2 + { a: 1 });//2[object Object]
    // console.log([] + {});//[object Object]
    // console.log({} + []);//[object Object]
    // console.log(3 + {});//3[object Object]
    // console.log({} + 3);//[object Object]3
    // 答案：如上
    // 解析：知识点加号运算符存在隐式类型转换，其中加对象时，相当于数值+"[object Object]",充当字符串连接符

    // 24. 下面代码的执行结果是什么？为什么
    // var a = {},b={key:"b"},c={key:'c'};
    // a[b] = 123;
    // a[c] = 456;
    // console.log(a[b]);
    // 答案：456
    // 解析：在设置对象的属性时，如果属性传入是一个对象，js会隐式的讲变量变成对象对应的[object Object]
    // 所以：a[b]和a[c]其实都相当于a["[object Object]"],所以他们操作的都是a对象的同一个属性，因此结果为456

    // 25. 下面代码的执行结果是什么？
    // for (var i = 0; i < 5; i++) {
    //     setTimeout(function () {
    //         console.log(i);
    //     }, i * 1000);
    // }
    // 答案：5 5 5 5 5
    // 解析:异步setTimeout是放在宏任务中，等执行完for循环之后再放到任务队列中执行
    // 可以用let或者立即执行函数解决
    // 方法一：
    // for(let i = 0;i<5;i++){
    //     setTimeout(function(){
    //         cosnole.log(i);
    //     },i*1000)
    // }
    // 方法二：
    // for (var i = 0; i < 5; i++) {
    //     (function(i){
    //         setTimeout(() => {
    //             console.log(i)//0 1 2 3 4
    //         }, i*100);
    //     }(i))
    // }

    // 26. 下面代码执行结果是？
    // var user = "Alice"
    // function changeUser(){
    //     user  = "Tom";
    //     return;
    //     function user(){
    //         console.log('user function')
    //     }
    // }
    // changeUser();
    // console.log(user);
    // 答案：Alice
    // 解析：原因很简答，在执行changeUser函数的时候，预编译将里头函数user提升了，后面改变user = "Tom"，改变的是changeUser函数里面的局部变量。

    // 27. 下面代码执行的结果是什么？
    // (function(){
    //     var user = author = "Alice";
    // }());
    // console.log(author);
    // console.log(user);
    // 答案：Alice、Uncaught ReferenceError: user is not defined
    // 解析：全局里面没有user，所以访问时会报错。而author是暗示全局变量，是有值的。

    // 28. 下面代码的执行结果是？
    // console.log(0 || 1);
    // console.log(1 || 2);
    // console.log(0 && 1);
    // console.log(1 && 2);
    // 答案是：1  1  0  2
    // 解析：||或运算，前面为真，返回前面的，前面为false，返回后面的
    // &&与运算符 前面为假，返回前面的，前面为真，返回后面的

    // 29. 下面代码的执行结果是什么？
    // console.log(1 + '2' + '3');
    // console.log(1 + +'2' + '3');
    // console.log(1 + -'1' + '2');
    // console.log(+'1' + '2' + '3');
    // console.log('A' - 'B' + "2");
    // console.log("A" - "B" + 2);
    // 答案：'123'  '33'  '02'  '123'  'NaN2'   NaN
    // 解析：（1）任何数据类型+字符串都为字符串；（2）一元正负可以将其变成数值型；
    // （3）非数字类型或者非数字型字符串字符串相减，值为NaN

    // 30. 下面代码的执行结果是？
    // (function(){
    //     try{
    //         throw new Error
    //     }catch(x){
    //         console.log(x)//Error
    //         var x = 1;
    //         var y = 2;
    //         console.log(x)//1
    //     }
    //     console.log(x);//undefined
    //     console.log(y);//2
    // })();
    //答案: 1 undefined 2
    // 解析：最开始执行匿名立即执行函数参数的作用域中，由于预编译将变量x和y提升了值为undefined
    // 当执行catch函数时，里面有自己的形参变量x，这里的值是错误信息：Error,后面赋值为1；所以里面catch中先打印Error后打印1
    // y被赋值为2;
    // 所以外面打印的值：x为undefined，y为改变的值2


    // 31. 下面代码的执行结果是？
    // var a = 10;
    // function fn() {
    //     console.log(this.a)
    // }
    // var obj = {
    //     a: 5,
    //     method: function (fn) {
    //         fn();//自己执行的，所有this指向window，打印出10
    //         arguments[0]();
    //     }
    // }
    // obj.method(fn, 1)
    // 答案：10 undefined
    // 解析：函数自己执行里面this指向window，
    // 函数传入另外一个函数作为参数，通过arguments[0]的形式调用，相当于arguments.0(),arguments.0就代表该函数，所以里面this指向arguments。
    // 再比如：
    // var length = 10;
    // function fn() {
    //     console.log(this.length)
    // }
    // var obj = {
    //     length: 5,
    //     method: function (fn) {
    //         fn();//自己执行的，所有this指向window，打印出10
    //         arguments[0]();//相当于arguments.0(),这里arguments的length为2，并且arguments.0中的0就是传入的fn，所以执行函数，相当于arguments调用。打印出2
    //     }
    // }
    // obj.method(fn, 1)
    // 答案是：10  2

    // 32. 下面代码的执行结果
    // var fn = function a(){
    //     a = 1;
    //     console.log(typeof a)
    // }
    // fn();//function
    // console.log(typeof a)//undefined
    // 答案：function  undefined
    // 解析：关于有名函数表达式需要注意2点：
    // （1）有名函数表达式的函数名（a）在函数体内还代表一个函数
    // （2）在函数体外部是会自动忽略函数的名称，即函数体外面是不能访问到（a）
    // （3）在函数体内部，函数名（a）不能再被修改

    // 33. 说说this和$(this)在jQuery中有什么不同？
    // 答案：this是js关键字中的一个，表示当前DOM元素；而$(this)返回的一个jQuery对象，可以调用jQuery中封装的方法

    // 34. 下面代码的执行结果是什么？
    // function fn1() {
    //     return {
    //         str: 'hello'
    //     }
    // }
    // function fn2() {
    //     return
    //     {
    //         str: 'hello'
    //     }
    // }
    // console.log(fn1());
    // console.log(fn2());
    // 答案：{str: "hello"}   undefined
    // 解析：js语言特性，如果语句表达是完整的，换行后默认会在语句后面加入‘;’
</script>