<script>
    // 1.【关于函数参数】下面代码的执行结果是什么
    // function getInfo(member, year) {
    //     member.name = "Alice";
    //     year = "2020"
    // }
    // var person = { name: "Tom" }
    // var brithYear = "2010";
    // getInfo(person, brithYear);
    // console.log(person, brithYear);
    // //答案：{name:Alice},2010


    // 2.【Event Loop】下面代码的执行结果是什么
    // var p = new Promise(resolve => {
    //     console.log(4);
    //     resolve(5);
    // });
    // function func1() {
    //     console.log(1)
    // }
    // function func2() {
    //     setTimeout(() => {
    //         console.log(2)
    //     });
    //     func1();
    //     console.log(3);
    //     p.then(resolved => {
    //         console.log(resolved)
    //     }).then(() => {
    //         console.log(6)
    //     });
    // }
    // func2();
    // 答案：4 1 3 5 6 2
    // 解析：事件循环机制，主程序执行完，再执行微队列，再执行宏队列；Promise then会先进入微队列，setTimeout进入宏队列。


    // 3. 下面的代码的执行结果是什么
    // function Car(){
    //     this.name = "BMW"
    //     return {
    //         name:"maserati"
    //     }
    // }
    // var car = new Car();
    // console.log(car.name);
    // 答案：maserati
    // 解析：new构造函数产生对象时，有显示返回一个对象的情况，this就是该对象。


    // 4. 模拟实现placeholder作用
    // <input type="text" name="user" value="请输入用户名" style="color:#999"
    //  onfocus="if(this.value=='请输入用户名'){this.value = '';this.style.color='#424242'}"
    //  onblur="if(this.value == ''){this.value = '请输入用户名';this.style.color='#999'}" >


    // 5. 下面代码的执行结果是什么
    // var a = 1;
    // var b = 2[a,b] = [b,a]
    // console.log(a,b)
    // 答案：a是1，b是[undefined , 1]   
    // 解析：预编译和包装类对象的结果


    // 6. 下面代码最后打印arr是什么
    // var arr = [1,2,3,4,5];
    // arr.length = 1;
    // 答案：[1]
    //解析：length会影响数组


    // 7.  下面代码执行结果是什么
    // var arr = [1+1,1*2,1/2];
    // console.log(arr);
    // 答案：[2,2,0.5]
    // 解析：数组保存的时候，每一位的表达式都会先运算


    // 8. 下面代码的执行结果是?
    // var one = (false || {} || null);
    // var two = (null || false || "");
    // var three = ([] || 0 || true);
    // console.log(one,two,three);
    // 答案：{},"",[]
    // 解析：本题考查||运算符的用法。其实记住一条规律：||运算符返回的是能确认最终结果的值！


    // 9. 下面代码执行结果是？
    // var h5course = false;
    // var result = h5course / 0;
    // if (result) {
    //     console.log(result * 2 + '2' + 4)
    // } else {
    //     console.log(!result * 2 + '2' + '4')
    // }
    // 答案："224"
    // 解析：0/0,null/0,undefined/0,false/0都为NaN，其他正数/0为infinity，其他负数除以0位-infinity。!NAN为true，true*2为2


    // 10. 下面代码执行结果是什么？
    // var a = 0, b=0;
    // function A(a){
    //     A = function(b){
    //         alert(a + b++)
    //     }
    //     alert(a++)
    // }
    // A(1)
    // A(2)
    // 答案：1，4
    // 解析：深入预编译和闭包就会得出结果，如下：
    // 首先：A(1)执行前 全局GO{
    //                         a：0,
    //                         b：0,
    //                         A：function A(a){}
    //                     }
    // 当A(1)执行的时候会产生一个放在自己作用域最顶端的的AO：{
    //                                                     a:1
    //                                                   }
    //                                               GO变成：{
    //                                                   a:0,
    //                                                   b:0,
    //                                                   A:function(b){alert(a + b++)}
    //                                                     //注意这里相当于window.A = function(b){alert(a + b++)},
    //                                                     //就跟函数保存到外部一样，产生了闭包。会拿着A(1)执行的AO{a:2}
    //                                               }   
    // 所以这里console.log(a++)，对应的是自己的AO里的a，后++，即打印出：1 ， 然后AO里面的a变成2，执行完销毁AO，
    // 注意：当A(2)执行的时候是执行GO里的A:function(b){alert(a + b++)}
    // 所以A(2)执行时，其[[scope]][0]是全新的AO{                        
    //                                          b：2                                  
    //                                      }
    //                          [[scope]][1]：{
    //                                          a：2
    //                                       }  
    //                          [[scope]][2]是GO{
    //                                           a:0,
    //                                           b:0,
    //                                           A:function(b){alert(a + b++)}
    //                                       }          
    // 所以alert(a + b++)，即2 + 2 ,这里打印出4
    // 所以最后结果分别打出1，4

    // 11. 下面代码的执行结果是？
    // var str = new Array(5).toString()
    // console.log(str);
    // 答案：",,,,"
    // 解析：new Array(n) 返回的是以length为n、每一位为空的数组。
    // 所以正因为new Array有这样那样的问题，一般推荐使用字面量如：var arr = [5]


    // 12. 下面代码的执行结果是什么？
    // console.log(123..toString());
    // 答案："123"
    // 解析：包装类的原因，js会将123.通过new Number(123.)打包成包装类对象。调用的是Number.prototype.toString
    // 所以new Number(123.).toString === Number.prototype.toString   


    // 13. 下面代码的执行结果是？
    // var x = 1;
    // var y = 2;
    // function show() {
    //     var x = 3;
    //     return {
    //         x: x,
    //         fun: function (a, b) {
    //             x = a + b;
    //         }
    //     }
    // }
    // var obj = show();
    // obj.fun(x, y);
    // console.log(obj.x)
    // console.log(x)
    // 答案：3，1
    // 解析：考查知识点闭包和预编译
    // 首先：
    // GO:{
    //     x:1,
    //     y:2,
    //     show:function(){},
    //     obj:undefined
    // }
    // 接着执行到obj = show(),show执行产生一个自己的AO
    // AO:{
    //     x:3
    // }
    //同时返回一个对象，形成闭包，obj={
    //                             x: 3,
    //                             fun: function(a, b) {
    //                                     x = a + b;
    //                                 }
    //                             }
    // 接着执行obj.fun(x,y),即：obj.fun(1,2)
    // 到这里一起来屡屡fun的[[scope]]
    // [[scope]][0]---->{
    //     a:1,
    //     b:2
    // }
    // [[scope]][1]---->{
    //     x:3
    // }
    // [[scope]][2]---->{
    //     x:1,
    //     y:2,
    //     show:function(){},
    //     obj:{x:3,fun:function(){}},
    // }
    // 所以执行obj.fun(1,2)时，里头就是x = 3，而GO上的x没有改变
    // 这时候console.log(obj.x)，打印3；console.log(x)也为1

    // 14. 下面的代码执行结果是？
    // var a = (true + false) > 2 + true;
    // console.log(a);
    // 答案：false
    // 解析：涉及知识点运算符的计算顺序和类型转换；
    // 有()先算()，存在隐式类型转换true + false 变成1+0，
    // 算数运算优先比较运算符，所以先算2+1
    // 最后比较是：1>3 得出false


    // 15. 说说运算符的优先级
    // 【小括号()】 > 【逻辑非!】 > 【算数*/%】> 【算数+-】> 【关系比较><==】 > 【逻辑与&&、逻辑或||】 > 【三目 ? :】 > 【赋值=】
    // 大致是这样，具体可以查看这篇文档，里面有个表：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence


    // 16. 下面代码执行结果是？
    // var num = 3;
    // console.log(num.toString(2));
    // console.log(num.toFixed(2));
    // 答案：11、3.00
    // 解析：toString方法传入一个参数时，表示把一个数当成10进制转成对应的进制的数，这里3被当成10进制，变成2进制就是11；
    // toFixed方法把目标数变成保留指定位数的小数，注意会四舍五入！这里保留两位小数，即变成3.00

    // 17. 下面代码的执行结果是什么？
    // function a(x){
    //     return x*2
    // }
    // var a;
    // console.log(a);
    // 答案：function a(x){return x*2}

    // 18. 下面代码的运行结果是什么？
    // debugger
    // function fun(n, o) {
    //     console.log(o);
    //     return {
    //         fun: function (m) {
    //             return fun(m, n);
    //         }
    //     }
    // }
    // var a = fun(0);
    // a.fun(1);
    // a.fun(2);
    // a.fun(3);
    // var b = fun(0).fun(1).fun(2).fun(3);
    // var c = fun(0).fun(2);
    // c.fun(2);
    // c.fun(3);
    // 答案：
    // undefined 0 0 0 
    // undefined 0 1 2 
    // undefined 0 2 2
    // 解析：预编译结束后
        // GO{
        //     a: undefined,
        //     b: undefined,
        //     c: undefined,
        //     fun: function(){}
        // }      
    //会首先会执行a = fun(0)，fun(0)执行产生一个fun执行的AO
    //         AO{
    //             n:0,
    //             o:undefined
    //         }       
    // 这个时候 console.log(o); 打印出【undefined】        
    // 接着a被赋值成一个对象,即GO变化了，如下
        // GO{
        //     a: {
        //         fun:function(m){
        //             return fun(m,n)
        //         }
        //     },
        //     b: undefined,
        //     c: undefined,
        //     fun: function(){}
        // }
    // 接着a.fun(1)，即返回fun(m)执行的结果，这里fun(m)执行也会产生一个自己的AO
    //         AO{
    //             m:1
    //         }
    // fun(m)执行的结果就是fun(m,n)执行，这里m为1，n就是之前传进来的n，是0，即o变成0，即执行GO里的fun函数，console.log(o)即打印出：【0】
    // 执行完销毁自己的AO
    // 接着执行a.fun(2);又回到a.fun(1)一样的执行过程。在执行前a是拿着的[[scope]]是
//         AO{
//             n:0,
//             o:0
//         } 
        // GO{
        //     a: {
        //         fun:function(m){
        //             return fun(m,n)
        //         }
        //     },
        //     b: undefined,
        //     c: undefined,
        //     fun: function(){}
        // } 
    // 当fun(2)执行，即返回fun(m)执行的结果，这里fun(m)执行也会产生一个自己的AO
    //         AO{
    //             m:2
    //         }
    // 结果还是没改变o，所以console.log(o)还是打印【0】
    // a.fun(3);也一样，还是打印【0】

    // 接着b=fun(0).fun(1).fun(2).fun(3)
    // fun(0) 这时：n等于0，o等于undefined，所以先打印【undefined】，返回{fun:function(m){return fun(m,n)}}
    // 接着执行里面的fun(1),即执行fun(1，0) 打印o为【0】，继续返回{fun:function(m){return fun(m,n)}}等待调用，这时的
    // 接着执行后面返回fun函数，传入的m为2，即执行fun(2,1)，打印o为【1】，继续返回{fun:function(m){return fun(m,n)}}等待调用
    // 接着执行后面返回fun函数，传入的m为3，即执行fun(3,2)，打印o为【2】，继续返回{fun:function(m){return fun(m,n)}}等待调用
</script>